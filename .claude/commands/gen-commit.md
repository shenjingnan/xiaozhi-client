---
description: 生成代码评审友好的 commit 信息
---

### 我希望你提供给我的内容

1. 符合 git 规范的 commit 标题和详细说明
2. 你认为合理的一个分支名称
3. 生成的 commit 信息必须是中文
4. **重点**：提供便于代码评审人快速理解改动的完整信息

### 代码评审友好的 commit 信息要求

一个好的 commit 信息应该让评审人能够：

- 快速理解改动的背景和动机
- 明确知道改动的范围和影响
- 了解技术实现的关键点
- 知道如何验证改动的正确性

### 一些提示信息

1. 你可以通过命令：git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@' 知道当前仓库的主分支名称
2. 获取主分支名称后，需要与远端主分支进行对比，因为本地主分支代码可能落后
3. 当前本地的 origin 可能不是最新，应该先执行 `git fetch origin` 更新
4. 优先检查未 git add 的改动
5. 执行命令时避免交互操作，因为无法进行用户干预。推荐使用 `--no-pager` 选项：
   - 避免：`git diff origin/main HEAD <filePath>`（需要手动按 q 退出）
   - 推荐：`git --no-pager diff origin/main <filePath>`
6. 注意：`git --no-pager diff origin/main HEAD <filePath>` 可能无法获取改动内容，而 `git --no-pager diff origin/main <filePath>` 可以正常获取。避免在命令中添加 `HEAD` 以确保能正确看到改动。

### 我的要求

**基本要求：**

- commit 标题符合 git 规范，简洁明确，不超过 50 字符
- 忽略当前分支名称（不具有参考价值）
- 仅提供 commit 信息建议，不执行实际的代码提交操作

**Type 类型：**

- `feat`：新增 feature
- `fix`：修复 bug
- `docs`：仅仅修改了文档，比如 README、CHANGELOG、CONTRIBUTE 等等
- `style`：仅仅修改了空格、格式缩进、逗号等等，不改变代码逻辑
- `refactor`：代码重构，没有加新功能或者修复 bug
- `perf`：优化相关，比如提升性能、体验
- `test`：测试用例，包括单元测试、集成测试等
- `chore`：改变构建流程、或者增加依赖库、工具等
- `revert`：回滚到上一个版本

**分支命名规范：**

- 使用前缀：`feature/`、`bugfix/`、`docs/`、`test/`
- 分支名简洁反映改动内容，采用 kebab-case 格式

**Commit 信息结构要求：**

```
<type>(<scope>): <subject>

## 背景
（为什么要做这个改动？解决了什么问题？满足了什么需求？）

## 主要改动
（具体改了什么？包括但不限于：）
- 新增/删除/修改了哪些功能
- 重构了哪些模块
- 优化了哪些方面
- 修复了什么具体问题

## 技术实现
（如何实现的？关键的技术方案或设计决策）

## 影响范围
（这个改动会影响哪些部分？）
- 前端/后端/数据库/配置等
- 是否有兼容性影响
- 是否需要额外的部署步骤

## 测试验证
（如何验证改动的正确性？）
- 增加了哪些测试用例
- 手动测试的场景
- 性能测试结果（如适用）

## 注意事项
（评审人需要特别注意的地方）
- 潜在的风险点
- 依赖的外部条件
- 后续需要跟进的工作
```

**输出格式：**

```text
<分支名称>
```

```text
<type>(<scope>): <subject>

## 背景
<background_description>

## 主要改动
<main_changes>

## 技术实现
<technical_implementation>

## 影响范围
<impact_scope>

## 测试验证
<testing_verification>

## 注意事项
<notes>
```

### Commit 示例模板

**示例 1：功能开发**

```
feat(api): 新增用户认证接口

## 背景
为了提升系统安全性，需要实现基于 JWT 的用户认证机制，支持用户注册、登录和权限验证功能。

## 主要改动
- 新增了 UserAuthController 控制器
- 实现了 register、login、refresh-token 三个核心接口
- 添加了 JWT token 生成和验证逻辑
- 集成了密码加密和验证功能

## 技术实现
- 使用 bcrypt 进行密码哈希处理
- 采用 RS256 算法生成 JWT token
- 实现了 token 自动刷新机制
- 添加了请求频率限制防止暴力破解

## 影响范围
- 后端 API：新增 /api/auth/* 路由
- 数据库：新增 users 表用于存储用户信息
- 前端：需要适配新的认证流程
- 兼容性：无向后兼容影响

## 测试验证
- 新增了 15 个单元测试用例覆盖认证逻辑
- 进行了集成测试验证完整认证流程
- 压力测试显示 API 响应时间 < 100ms
- 安全测试通过 SQL 注入和 XSS 防护验证

## 注意事项
- 需要在生产环境配置正确的 JWT 密钥
- 建议启用 HTTPS 保护 token 传输安全
- 后续需要实现权限管理和角色控制
```

**示例 2：Bug 修复**

```
fix(core): 修复内存泄漏导致的性能问题

## 背景
在生产环境中发现长时间运行后出现内存持续增长的问题，最终导致服务崩溃。经过分析发现是事件监听器未正确移除导致的内存泄漏。

## 主要改动
- 修复了 EventEmitter 事件监听器未移除的问题
- 优化了对象池的内存管理机制
- 添加了内存使用监控和告警功能
- 重构了资源清理逻辑

## 技术实现
- 使用 WeakMap 替代 Map 存储临时引用
- 实现了自动垃圾回收机制
- 添加了内存阈值监控，超过 80% 时触发清理
- 采用 RAII 模式确保资源正确释放

## 影响范围
- 核心服务：所有使用 EventEmitter 的模块
- 性能：内存使用优化约 30%
- 监控：新增内存使用指标
- 兼容性：API 接口保持不变

## 测试验证
- 进行了 24 小时压力测试，内存使用保持稳定
- 添加了内存泄漏检测的自动化测试
- 验证了在高并发场景下的稳定性
- 确认了所有现有功能的正常运行

## 注意事项
- 建议在低峰时段部署此修复
- 部署后需要密切监控内存使用情况
- 如有异常回滚，需要重启相关服务
```

**示例 3：代码重构**

```
refactor(utils): 重构配置管理模块提升可维护性

## 背景
原有的配置管理模块代码结构混乱，职责不清晰，存在大量重复代码，难以维护和扩展。为了提升代码质量和开发效率，需要进行全面重构。

## 主要改动
- 将配置管理拆分为 ConfigLoader、ConfigValidator、ConfigCache 三个独立模块
- 移除了重复的配置加载逻辑
- 优化了配置缓存机制，提升加载性能
- 统一了配置验证规则和错误处理

## 技术实现
- 采用单例模式确保配置管理器的唯一性
- 使用策略模式支持多种配置源（文件、环境变量、远程配置）
- 实现了配置热更新机制，无需重启服务
- 添加了配置版本控制和回滚功能

## 影响范围
- 工具模块：所有依赖配置管理的组件
- API：配置加载接口保持兼容
- 性能：配置加载速度提升约 50%
- 维护性：代码复杂度降低，测试覆盖率提升

## 测试验证
- 新增了 25 个单元测试，覆盖率达到 95%
- 进行了兼容性测试，确保现有功能不受影响
- 性能测试显示配置加载时间显著减少
- 验证了配置热更新功能的正确性

## 注意事项
- 需要更新相关的开发文档
- 建议对开发团队进行新模块使用培训
- 后续可以考虑迁移到更成熟的配置中心
```

### 生成 Commit 时的注意事项

1. **保持真实性**：基于实际代码改动生成信息，不要虚构不存在的内容
2. **突出重点**：评审人最关心的是"为什么改"和"改了什么"
3. **具体明确**：避免模糊的描述，如"优化了性能"应具体说明如何优化
4. **结构清晰**：按照模板结构组织信息，便于快速阅读
5. **技术准确**：确保技术实现描述的准确性和专业性
